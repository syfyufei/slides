---
title: "数据清理"
subtitle: "Munging Within a Dataset"
runtime: shiny_prerendered
---

# 数据清理 {#sec-munging}

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE,
                      message = FALSE,
                      warning = FALSE,
                      out.width="100%")

if (!require(pacman)) install.packages("pacman")

p_load(drhur,
       here,
       rio,
       tidyverse)
```
## 导言

整理数据是分析数据前的必要步骤。在绝大多数情况下，没有数据能够直接满足数据分析的需求，都要经过整理之后才能使用，而这一步甚至会占据处理数据的大部分时间。这一讲将介绍R语言整理数据的常见方式。学好这一讲内容，能够让你的数据处理过程更加高效。

## 知识点

:::{.callout-tip}
- 研究问题：
   - 有几份涉及不同地区的调查数据，包括：非洲政治晴雨表调查数据、亚洲政治晴雨表调查数据、拉美政治晴雨表调查数据。  
   你想创造一个全球的政治晴雨表调查数据，应该怎么合并这些数据集呢？（提示：行合并）
   - 现在有两份数据：  
     数据1：中国各省份年度不平等认知的调查数据  
     数据2：各省年度省内收入差距数据     
     如果你想研究省内收入差距对居民不平等认知的影响，你应该如何合并这两份数据呢？（提示：索引合并，以省份与年度为索引）

:::
   
   在上述问题中，我们已经涉及到了处理数据的几个常见情景及方法：
:::{.callout-tip} 
- 单数据整理
    - 探索
    - 梳理
    - 筛选
    - 修改
- 跨数据整理
    - 直接合并
    - 索引合并

:::
接下来，让我们正式开始基于R的数据处理操作教学吧！

## 演示数据

![](images/wvs7.jfif){height=400}

我们从已故政治学教授Ronald Inglehart创立的[World Values Survey](https://www.worldvaluessurvey.org/wvs.jsp)第七波数据（WVS7）的一个样本进行演示。
这个样本是WVS7中2%的数据，包含24个变量。
具体变量信息可通过`?drhur::wvs7`查看。

## 数据探索

数据探索指对陌生数据的数据构成、结构、形式、内容的初步了解，是数据分析的第一步，也是关键一步。

### 概览原始数据

drhur包已内置了`wvs7`，可以直接输入名称返回数据细节。

```{r glimpse, exercise = TRUE, exercise.eval = TRUE}
wvs7
```

R语言的传统数据框格式是data.frame，后来又出现了基于tibble包或者tidyverse包的tibble数据框格式。tidyverse包是一系列数据包的集合，包含了tibble在内的tidyr、dplyr、stringr等一系列关于数据清洗的包。相较于data.frame，tibble具有兼容更多数据类型、变量命名等优点，实际操作会更加便捷。
:::{.callout-tip}
阅读数据框，可以从三个维度来定位。

- 数据框的三个维度
    - 行：观测单元。
    - 列：变量。
    - 单元：数值。

::: 
一般而言，行和列顺序的改变不会影响数据信息，但行和列的错位变化意味着原属于另一个样本的值挪到了其他样本里，就会导致数据信息改变。

### 了解数据结构

:::{.callout-tip}
- 观测量
- 变量名及数量
- 数据结构

:::
如果直接用`wvs7`查看数据：

```{r systemView, exercise = TRUE}
wvs7
```

可能会存在行和列过多，难以直接观察数据特征的问题。这时，可以通过几个简单的函数查询数据框的行数、列数、列名。

```{r systemView-solution}
nrow(wvs7) # 获取数据的行数
ncol(wvs7) # 获取数据的列数
names(wvs7) # 获取变量名/列名
str(wvs7) # 获取变量名、变量名类型、行数、列数
```


### 变量提取

基于数据讨论变量特征，首先要了解如何表达数据和变量的从属关系。
包括R在内的OOP系统非常擅长多数据、多变量的协同使用和分析。
换言之，与一些常见数据分析软件不同，R可以同时加载和综合使用多个数据——只要将他们存入不同的对象即可。

如果要提取数据框中的一列，至少有两种常用的方式：

第一种是用`[a,b]`定位行、列的方式来提取，`a`与`b`分别指的是列和行。在只填写列名的情况下，以`<数据框>[,<变量名>]`为形式就明确指向了数据中的某一列，例如表示`wvs7`中的`country`：

```{r variable, exercise = TRUE}
wvs7[, "country"]
```

还有一种就是用`<数据框>$<变量名>`来表示：

```{r variable-solution}
wvs7$country
```

### 变量特征

变量信息提取与上一节中的向量信息提取完全一致。
我们可以通过`table`命令获得变量分布，
另一种常用的变量特征查看方式是通过`summary`命令获得常见变量信息。`summary`会依据数据类型显示不同的数据特征，例如同样是查询`wvs7`中的`age`，就能找到查看平均值、最小值、最大值等信息。
当然，R也支持获取年龄变量的总和、平均数、中位数、最小值、最大值、方差、IQR等，这些方法我们会在下一节仔细讨论。

```{r varCal, exercise = TRUE}
table(wvs7$age)
summary(wvs7$age)
```

对于非数值型变量，我们可以通过总结表的形式获取他们的信息。例如查询`wvs7`中的`femal`和`maritial`，作为二元变量`femal`分TRUE和FALSE返回值的个数，而分类变量`maritial`按照类型返回值的个数。

```{r varCat}
table(wvs7$female)
table(wvs7$marital)
```

对于基于factor的变量，我们还能提取他们的层级信息，也就是不同层级的名称。

```{r varLevel}
levels(wvs7$religious)
levels(wvs7$marital)
```

### 变量属性

变量可能由于其类型不同而具有不同的特征，比如类别向量就没法求平均值，因此`mean`对于他们就是无意义的。
但所有变量都具有一些属性特征，比如变量的长度、类别、特征值等。
而对这些特征的提取命令也是共通的。常见的又求变量长度的`length`命令，去除重复值的`unique`命令，获取系列基本信息的`summary`命令，获取变量类型的`class`命令，查看年份元素类型的`typoof`命令。

用`wvs7`来尝试一下他们的使用方法吧！


```{r varAttr}

```

```{r varAttr-solution}
length(wvs7$age) #求取年份的长度（此处为行数）
unique(wvs7$age)

summary(wvs7$age) #获取年份的上述所有信息
class(wvs7$age) #查看年份结构：vector、matrix、array、dataframe、list
typeof(wvs7$age) #查看年份元素类型
```

### 变量总览

关于`summary`命令的使用方法已多次提及，此处便不再赘述。`summary`命令既可以用于单个变量，也可以用于整个数据框。

```{r summary}
summary(wvs7$age)
summary(wvs7)
```

## 数据梳理

如果说数据探索是从数据中看变量，那么数据梳理就是以变量为索引来了解数据。
从实用角度出发，我们这里直接介绍如何使用`tidyverse`进行数据梳理。
但其实绝大部分数据梳理都是可以通过R的自带语句完成的。
我们也将自带语句对于同一任务的操作放置在“提示”单元中。

### 

:::{.callout-note}
首先介绍一下`tidyverse`

+ `tidyverse`是一个R包，包含了绝大多数数据梳理会使用到的功能。
+ 实际上，`tidyverse`是一群[R包](https://www.tidyverse.org/packages/)的汇总，包括了`tidyr`、`dyplr`、`stringr`、`tibble`等数据梳理常用包。
+ 像漫威和DC漫画宇宙一样，所有`tidyverse`组成成员都在同一个数据结构内工作，可以相互对话，共同使用。

![](images/tidyverseHive.png){height=300}
:::

### 安装

首先，我们通过常用的`install.package`命令和`library`命令安装和打开`tidyverse`包。当你打开`tidyverse`包后，就等于一次性地打开了`tidyverse`家族的所有包，不必再重复打开它的子包。

```{r loadTidy, eval=FALSE}
install.packages("tidyverse")
library("tidyverse")
```

### `dplyr`包

`dplyr`是`tidyverse`中专门负责数据清理的组件，贯彻一个命令做一件事的风格，基本满足各项数据清理的需求。数据清理要完成的工作是将已有数据整理成为方便直接进行数据分析的格式，一般包括对变量命名、变量类型、变量值的表示方式等一系列调整。

![](images/data-wrangling-cheatsheet.png)
<!-- 睿哲，请在网上找到中文cheatsheet,截图替换，并标明出处【回复：实在是找不到中文的，暂时用印纹版替换。】 -->
常用数据包往往会有对应的速查表（cheatsheet）。例如，dplyr包的速查表可以通过R语言的开发方`Posit`的[官网](https://www.rstudio.com/wp-content/uploads/2015/02/data-wrangling-cheatsheet.pdf)获取。其他常见的数据包亦如此。

### 通道

在逐一介绍`dplyr`的主要命令前，我们要先说明一下“通道”（pipe）。“通道”是一种常用的命令连接方式，通过通道可以将上一个命令的数据处理结果传输给下一个命令。搭建通道后，就如同建立了除了某一数据的流水线，不同命令如同站在流水线旁的操作者，依次对命令进行加工，最终得到成品。

:::{.callout-tip}
通道在R中可以直接使用`|>`表示，在打开`dplyr`后还可以使用功能更强的`%>%`。
我们后面的例子直接使用后者。
在R中，通道起到连接对于同一个对象的连续动作。对于命令书写者而言，相当于动作游戏中“搓”一个连续技。

![](images/comboAttack.gif){height=400}
:::
###

站在代码阅读的角度而言，通道也能让每个命令排布更加明确、易读。
再举一个例子，如果我们用代码来模拟煮饺子的全过程，大体是这样：

```{r embeddedCode, eval=FALSE}
eat_dumpling <- 
eat(
  dip(
    cook(
      fill(
        mix(
          meat, 
          with = c(salt, soy_sauce, green_onion, ginger)
          ), 
        with = wrapper
        ), 
      in = boilled_water
      ), 
    in = vinegar)
  )
```

在这里，我们通过括号的层层嵌套来实现对统一数据处理的顺序排列，通过对括号内容的从里层括号向外层括号的读取实现了煮饺子的系列动作。但很明显，这种表达方式对于读者而言并不是很友好。

###

使用通道后，可以写成这样：

```{r pipeCode, eval=FALSE}
eat_dumpling <- 
mix(meat, with = c(salt, soy_sauce, green_onion, ginger)) %>% 
  fill(with = wrapper) %>% 
  cook(in = boilled_water) %>% 
  dip(in = vinegar) %>% 
  eat
```

`%>%`使得只用在第一次使用命令时写出对象，命令之间用`%>%`，自第二个命令起默认不再写出对象即可。通过这个方法，可以将若干步骤按照更符合日常书写习惯的“从左到右”的方式将命令连接起来。

:::{.callout-note}
作为常用符号的`%>%`有相对应的快捷键:

* Windows环境：Ctrl + Shift + M
* Mac环境：Cmd + Shift + M

:::

### 变量筛选

`select`命令能够通过变量名从数据框中提取特定的若干变量，语法如下：

`select(<data>, <var1>, <var2>, ...)`

现在`wvs7`数据中有24个变量，有一些有意思的变量排在后面不方便看到，我们希望看到一个只有国家、年龄、教育水平和对政府信心的数据框：

```{r select, exercise=TRUE}
select(wvs7, country, age, education, confidence_gov)

# 如果我们想看到关于信心的所有变量，除了逐个列出来以外还能怎么做？
```

```{r select-solution}
select(wvs7, country, age, education, starts_with("confidence"))
```

:::{.callout-note}
`starts_with`命令可以将以某一串字符作为变量名称开头的变量都提取出来，这样就不用逐一列举完整的变量名称实现筛选了。和`starts_with`类似的还有`ends_with`和`matches`。

> 提示：注意第三人称变单数😝

:::

### 

还有一种筛选变量的方式是在原数据框的变量范围内删除特定变量。删除变量可以通过`-`实现：

```{r deselect}
select(wvs7, -(country:education))
```

此外，`(A:B)`表示的是从`A`到`B`之间的各变量。通过上述命令，可以实现将`wvs7`中去除从`country`到`education`的变量，提取剩余的变量。

###

一个`select`衍生体是`rename`，语法为`new.name = old.name`

```{r rename, exercise = TRUE}
rename(wvs7, nationality = country)
```

在`rename`命令中，可以同时修改多个变量的名称，用法，按照`rename(<数据框>, <新名称1> = <旧名称1>, <新名称2> = <旧名称2>,···)`的语法结构添加即可。

### 数据排序

将变量值按照特定规律（例如大小）排序常用的是`arrange`命令。

`arrange(<data>,...)`

比如我们好奇最年轻的人群对国家机关的信心，并对应他们的教育水平、收入水平等信息。首先，我们提取相关变量，形成一个数据框。

```{r arrange, exercise = TRUE}
select(wvs7, age, confidence_gov, education, incomeLevel)
```

然后选择凭借年龄（默认从小到大）对各行进行排序：

```{r arrange-solution}
select(wvs7, age, confidence_gov, education, incomeLevel) %>% 
  arrange(age)
```

如果要查看最年长的那群人呢？在这里，就需要通过倒序排列来实现，可以通过在`arrange`命令中嵌套`desc`命令来实现。

```{r arrangeDesc, exercise = TRUE}
select(wvs7, age, confidence_gov, education, incomeLevel) %>% 
  arrange(desc(age))

## 如果我们想知道最年轻又教育最高的人呢？
```

```{r arrangeDesc-solution}
select(wvs7, age, confidence_gov, education, incomeLevel) %>% 
  arrange(age, desc(education))
```

`arrange`命令可以按照多种变量特征来排序。在有多个排列标准时，会按照列举的变量逐一满足排序需求。例如同时给`age`和`education`排序的话，`arrange`命令会优先按照年龄从小到大排序，在age相同的情况下，会按照教育程度从高到低排序。

### 变量值筛选

前面提到`select`是对数据库变量的筛选，`filter`则基于变量值的筛选。
延续上面的例子，如果我们好奇*美国*最年轻的一群人对国家机关的信心以及他们的教育水平和收入水平。

类似地，我们先把相关变量筛选出来，然后按照年龄从小到大排序。

```{r filter, exercise=TRUE}
select(wvs7, age, confidence_gov, education, incomeLevel) %>% 
  arrange(age)
```

接下来，我们通过`filter`命令添加对国籍的筛选要求，把`country`中变量值为`United States`的行筛选出来。也可以进一步地通过`filter`提取年龄最小值的那一组美国人的数据。

```{r filter-solution}
select(wvs7, age, confidence_gov, education, incomeLevel, country) %>% 
  filter(country == "United States") %>% 
  arrange(age)

select(wvs7, age, confidence_gov, education, incomeLevel, country) %>% 
  filter(country == "United States") %>% 
  filter(age == min(age, na.rm = TRUE))
```

### 数据修改

在数据分析中，我们常常要将数据进行调整和再加工，`mutate`可以帮你做到这一点。
英文中“mutate”表示“变异”，也就是说这个函数可以实现的并不是无中生有，而是改头换面，是基于既有变量的值按照特定要求生成新的变量。


###

如果我们关心教育水平对收入水平差异的影响，我们可以建立一个比例变量。具体而言，可以通过`wvs7`中的
`incomeLevel`和`education`来生成新的变量`ratio_incomeEdu`。

```{r mutate, exercise = TRUE}
mutate(wvs7, ratio_incomeEdu = incomeLevel / (education + 1)) %>%
  select(country, incomeLevel, education, ratio_incomeEdu) %>%
  arrange(desc(ratio_incomeEdu))

# 如果要把`ratio_incomeEdu`变成一个百分数，怎么办？
```

```{r mutate-solution}
mutate(wvs7, 
       ratio_incomeEdu = incomeLevel / (education + 1),
       ratio_incomeEdu = as.numeric(ratio_incomeEdu) %>%
         scales::percent()) %>%
  select(country, ratio_incomeEdu)
```


### 数值统计

`count`用来基于数据计数。
比如，可以使用count来计算我们的数据中男性、女性各有多少人。^[这种列表在人口普查等统计数据中非常常见。]

```{r count, exercise = TRUE}
wvs7 %>%
  count(female)

# 如果想知道不同年龄段的男女数量怎么办呢？
```

```{r count-solution}
wvs7 %>%
  count(age, female)
```

在列举多个变量的情况下，`count`会按照多个变量的值返回不同组合的个数。

### 

`summarise` 用来将个体数据转换成统计数据。
比如，我们想获得样本的年龄和教育水平平均数：


```{r summarise, exercise = TRUE}
wvs7 %>%
  summarise(age = mean(age, na.rm = TRUE),
            edu = mean(education, na.rm = TRUE))
```

返回结果将是两个变量的平均数构成的tibble数据框。

### 

分组也是数据梳理中常用的一种操作，可以通过某一变量的特征对数据框的各行进行分类。
`group_by`命令使分组操作成为可能：

```{r ex_summaryG, exercise = TRUE}
wvs7 %>%
  group_by(female) %>% 
  summarise(age = mean(age, na.rm = TRUE),
            edu = mean(education, na.rm = TRUE))
```

在这里，我们依据`female`将`wvs7`的数据分成了两组，并分别求了年龄和教育程度的平均值。

`group_by`实际是为现有数据建立群体索引，之后的所有操作都将在分组进行。
当完成分组后所必须的工作后，可以撤销分组，`group_by`命令的逆操作是`ungroup`，指定已分组的对象输入命令后即可解散分组。

## Bonus

:::{.callout-tip}
怎么样才能填补缺失的 `x`, 然后把 `y` 和 `z` 合并成一个变量呢?

```{r coalesce, exercise = TRUE}
df_toy <- data.frame(x = sample(c(1:2, NA, NA, NA)),
                     y = c(1, 2, NA, NA, 5),
                     z = c(NA, NA, 3, 4, 5))

df_toy
```


```{r coalesce-solution}
df_toy %>%
  mutate(x = coalesce(x, 0L),
         yz = coalesce(y, z)) # Ta-da~~~
```

在这里，可以通过`coalesce`命令来实现缺失值替换。其中，`x = coalesce(x, 0L)`表示用`0L`来替换向`x`中存在的缺失值。
还有一种常见的操作是对比替换，即`yz = coalesce(y, z)`所实现的功能：
通过对比`y`和`z`的变量值，将`y`中的空缺值用`z`中对应位置的值来替代。
:::

## 数据整理原则

:::{.callout-tip}
我们上面的一系列操作都有一个共同的特点，你发现了吗？

```{r rawData}
head(wvs7)
```

- <span style="color:red">不碰</span>原始数据。正如`play`章节已详细讲述，不碰原始数据才能保障数据处理的安全性、可靠性，所有数据处理操作都需要通过代码完成。
- 对象覆盖需谨慎。尽量不用同名数据覆盖既有数据，避免在调用数据时混淆数据版本。

```{r overwrite, exercise}
wvs7 <- mutate(wvs7, female = as.numeric(female))
```
:::

## 数据整合

当我们分门别类地完成了数据梳理，一般需要将分散的数据整合为一个或者若干个数据框，以便后续的保存、调用。

### 直接合并

:::{.callout-tip}
直接合并的前提基本和矩阵运算是基本一致的：只有前列数对得上后行才能进行。

- 行合并： 列数<span style="color:red">相等</span>(其实，列数不想等也能够合并，但不等列合并会发生什么呢？我们很快就会揭晓。)
- 列合并： 行数<span style="color:red">相等</span>
:::

分别举个例子：
我们从`wvs7`里筛选出美国、俄国的样本数据，再合并获得一个美俄样本数据。

```{r bindRow, exercise = TRUE}
wvs7_us <- filter(wvs7, country == "United States")
wvs7_russia <- filter(wvs7, country == "Russia")

# 创建一个美俄样本数据

bind_rows(wvs7_us, wvs7_russia)

# 不等列行合并会发生什么？
```

`wvs7`里的美俄样本数据的列数是相等的，看不出来不等列合并的情况。在这里，我们虚构两个向量尝试一下不等列合并的情况：

```{r bindRow-hint}
# Try this
bind_rows(tibble(x = 1:3), tibble(y = 1:4))
```

可以看到，`bind_rows`命令的处理方式是将两个来源的行均视为不同的行，在行数上体现为两个数据框的累加。对于合并后不能对其的相应列部分通过`NA`补齐。

相对应地，如果要合并列，就需要调用`bind_cols`命令（可以发现，tidyverse对命令的命名很工整，可以直观理解`bind_rows`和`bind_cols`两个命令的异同）。接下来，我们分别提取了关于信心和信任的变量，再将其进行列合并。

```{r bindCol, exercise = TRUE}
wvs7_conf <- select(wvs7, starts_with("confidence"))
wvs7_trust <- select(wvs7, starts_with("trust"))

# 创建一个信心-信任数据

bind_cols(wvs7_conf, wvs7_trust)
```


### 索引合并

行合并和列合并是一种简单合并方式，通过`bind_rows`和`bind_cols`完成的行列合并并不一定能够满足各行数据来自于同一个样本，但这对于大多数数据而言，同一行的数据是不能错位的。这时，就可以通过索引合并来实现对行数据的一一对应地合并。  

索引合并指的是基于共享的索引序列（可以是任何变量）合并数据。也就是说，对于要合并的若干个数据而言，它们都应该拥有一个名称相同的向量作为索引序列，使得来源于不同数据框的数据能凭借该行数据的相同值实现一一对应的匹配，让属于同一行的数据能够对应合并起来，可以通过`merge`命令实现。

### 

此外，还有4种常见的数据合并方式。让我们先创建两个演示数据:

1. 个体层级平等认知数据；
1. 国家层级人口变量数据。

如果`wvs7_eq`是调查数据，`wvs7_country`是人口统计数据，我们的研究需要将这两组数据合并分析个体层级和国家层级变量间的关系。

```{r join, exercise = TRUE}
wvs7_eq <- select(wvs7, country, starts_with("equal")) %>% 
  filter(country %in% unique(country)[1:2])

wvs7_country <- group_by(wvs7, country) %>% 
  summarise(across(female:education, mean, na.rm = TRUE)) %>% 
  ungroup %>% 
  filter(country %in% unique(country)[2:3])
```

在上述代码中，我们提取了以`equal`开头的变量和`country`变量中按首字母排列的前两个国家的样本，从而组成了`wvs7_eq`。类似地，我们提取了从`female`到`education`之间的变量，并按照国家分类生成了平均数，其中`na.rm = TRUE`表示去除有缺失值的数据。

接下来，就可以通过内连接、左连接、右连接、全连接四种方式将两个数据合并。四种连接方式的语法都是`xxx_join(<数据1>,<数据2>)`

```{r join-solution}
inner_join(wvs7_eq, wvs7_country)
left_join(wvs7_eq, wvs7_country)
right_join(wvs7_eq, wvs7_country)
full_join(wvs7_eq, wvs7_country)
```

:::{.callout-note}
如果两个数据的行能够一一对应地合并，那么4种合并方式的结果都是相同的。但如果不是这样的情况，4种合并方式各有其合并逻辑。

- 内连接(inner_join)： 只连接能够匹配的行，忽略不能双向对应的数据。
- 左连接(left_join)： 以写在左边的数据框为准，让写在右边的数据框对应合并至左数据框，忽略不能合并至左数据框的数据。在这样的情况下，左数据框的数据都会被保留，不能被右数据框补齐的值以`NA`填充。
- 右连接(right_join)： 以写在右边的数据框为准，让写在左边的数据框对应合并至右数据框，忽略不能合并至右数据框的数据。在这样的情况下，不能被右数据框补齐的值以`NA`填充。
- 全连接(full_join)：简单合并左、右数据框，保留两个数据框的所有数据，不能补齐的值以`NA`填充。 
:::

## 总结

1. 行动<span style="color:red">之前</span> 想清楚;
1. 巧妙且综合地使用 `dplyr` 函数;
    + 探索: `head`, `tail`
        - 结构：`nrow`, `ncol`, `names`, `str`
        - 特征：`table`, `levels`
        - 属性：`length`, `unique`, `summary`, `class`, `typeof`
    + 梳理: `dplyr`命令集
1. 数据整合原则：不碰原数据
1. 数据合并
    - 直接合并：`bind_*`
    - 索引合并：`*_join`